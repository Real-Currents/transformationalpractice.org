'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _validation = require('./validation');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mutationObserverUnsupportedMessage = 'This browser does not support MutationObserver';

/**
 * Passthrough implementation of MutationObserver designed to make it easier to
 * use, handling DOM querying, browser compatibility, and other stuff like that
 * for you.
 */

var Darwin = function () {
  /**
   * @param  {Function} options.callback    Callback function to run when
   *                                        mutations occur
   * @param  {Array}    [options.targets]     Selectors of targets to observe
   */
  function Darwin(_ref) {
    var callback = _ref.callback,
        _ref$targets = _ref.targets,
        targets = _ref$targets === undefined ? [] : _ref$targets;
    (0, _classCallCheck3.default)(this, Darwin);

    this.MutationObserver = (0, _validation.checkForMutationObserver)();

    if (!this.MutationObserver) {
      console.error(mutationObserverUnsupportedMessage);
      return;
    }

    this.callback = (0, _validation.validateCallback)(callback);
    this.targets = targets;
  }

  /**
   * Creates a MutationObserver, and observes stored targets.
   *
   * @public
   */


  (0, _createClass3.default)(Darwin, [{
    key: 'init',
    value: function init() {
      if (!this.MutationObserver) {
        console.error(mutationObserverUnsupportedMessage);
        return;
      }
      this.observer = this.createObserver();
      this.observeTargets();
    }

    /**
     * Disconnects the MutationObserver, nulls it out, and removes the
     * DOMContentLoaded event listener added by evaluateMutations.
     *
     * @public
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      if (!this.MutationObserver) {
        console.error(mutationObserverUnsupportedMessage);
        return;
      }
      this.observer.disconnect();
      this.observer = null;
      document.removeEventListener('DOMContentLoaded', this.reactToMutations);
    }

    /**
     * Creates a new instance of MutationObserver using the correct API, with
     * this.evaluateMutations as the callback.
     *
     * @private
     * @return {MutationObserver}   Created instance of MutationObserver
     */

  }, {
    key: 'createObserver',
    value: function createObserver() {
      var _this = this;

      return new this.MutationObserver(function (mutations) {
        _this.evaluateMutations(mutations);
      });
    }

    /**
     * Loops through targets and instructs the created observer to observe them.
     *
     * @private
     */

  }, {
    key: 'observeTargets',
    value: function observeTargets() {
      var _this2 = this;

      this.targets.forEach(function (sel) {
        (0, _from2.default)(document.querySelectorAll(sel)).forEach(function (target) {
          _this2.observer.observe(target, {
            childList: true,
            subtree: true,
            attributes: true
          });
        });
      });
    }

    /**
     * MutationObserver callback. Given mutations that are observed, evaluate them
     * to see if they are the right type, and if so, react to them in the proper
     * manner. Has logic to protect against mutations observed before
     * DOMContentLoaded occurs.
     *
     * @private
     * @param  {Array} mutations   An array of MutationRecord objects
     */

  }, {
    key: 'evaluateMutations',
    value: function evaluateMutations(mutations) {
      if (!mutations) {
        return;
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', this.reactToMutations);
      } else {
        this.reactToMutations();
      }
    }

    /**
     * Upon mutation, call the callback that's passed in. Batches changes with the
     * setTimeout.
     *
     * @private
     * @method reactToMutations
     */

  }, {
    key: 'reactToMutations',
    value: function reactToMutations() {
      if (this.timer) {
        clearTimeout(this.timer);
      }
      this.timer = setTimeout(this.callback, 150);
    }
  }]);
  return Darwin;
}();

exports.default = Darwin;
module.exports = exports['default'];
//# sourceMappingURL=index.js.map