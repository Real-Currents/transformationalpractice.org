'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _urlParse = require('url-parse');

var _urlParse2 = _interopRequireDefault(_urlParse);

var _videoAutoplayTest = require('./utils/videoAutoplayTest');

var _videoAutoplayTest2 = _interopRequireDefault(_videoAutoplayTest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEBUG = false;

var DEFAULT_PROPERTY_VALUES = {
  'container': '.background-wrapper',
  'url': 'https://youtu.be/xkEmYQvJ_68',
  'fitMode': 'fill',
  'maxLoops': '',
  'scaleFactor': 1,
  'playbackSpeed': 1,
  'filter': 1,
  'filterStrength': 50,
  'timeCode': { 'start': 0, 'end': null },
  'useCustomFallbackImage': true
};

var FILTER_OPTIONS = require('./constants/filter.js').filterOptions;
var FILTER_PROPERTIES = require('./constants/filter.js').filterProperties;

var YOUTUBE_REGEX = /^.*(youtu\.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]{11}).*/;
var VIMEO_REGEX = /^.*(vimeo\.com\/)([0-9]{7,}(#t\=.*s)?)/;

/**
 * A class which uses the YouTube API to initialize an IFRAME with a YouTube video.
 * Additional display options and functionality are configured through a set of properties,
 * superceding default properties.
 */

var VideoBackground = function () {
  /**
   * @param {Object} props - An optional object with configuation.
   * @param {Object} windowContext - The parent window object (due to .sqs-site-frame).
   */
  function VideoBackground(props) {
    var _this = this;

    var windowContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;
    (0, _classCallCheck3.default)(this, VideoBackground);

    this.windowContext = windowContext;
    this.events = [];

    this.initializeProperties(props);
    (0, _videoAutoplayTest2.default)().then(function (value) {
      _this.canAutoPlay = true;
    }, function (reason) {
      _this.canAutoPlay = false;
      _this.container.classList.add('mobile');
      _this.logger('added mobile');
    }).then(function (value) {
      _this.setDisplayEffects();
      _this.setFallbackImage();
      _this.callVideoAPI();
      _this.bindUI();

      if (DEBUG === true) {
        window.vdbg = _this;
        _this.debugInterval = setInterval(function () {
          if (_this.player.getCurrentTime) {
            _this.logger((_this.player.getCurrentTime() / _this.player.getDuration()).toFixed(2));
          }
        }, 900);
      }
    });
  }

  (0, _createClass3.default)(VideoBackground, [{
    key: 'destroy',
    value: function destroy() {
      if (this.events) {
        this.events.forEach(function (evt) {
          return evt.target.removeEventListener(evt.type, evt.handler, true);
        });
      }
      this.events = null;

      if (this.player && typeof this.player.destroy === 'function') {
        this.player.iframe.classList.remove('ready');
        clearTimeout(this.player.playTimeout);
        this.player.playTimeout = null;
        this.player.destroy();
        this.player = {};
      }

      if (typeof this.timer === 'number') {
        clearTimeout(this.timer);
        this.timer = null;
      }

      if (typeof this.debugInterval === 'number') {
        clearInterval(this.debugInterval);
        this.debugInterval = null;
      }
    }
  }, {
    key: 'bindUI',
    value: function bindUI() {
      var _this2 = this;

      var resizeEvent = typeof window.orientation === 'undefined' ? 'resize' : 'orientationchange';
      var resizeHandler = function resizeHandler() {
        if (resizeEvent === 'resize' && _this2.player.iframe) {
          _this2.windowContext.requestAnimationFrame(function () {
            _this2.scaleVideo();
          });
        } else if (_this2.useCustomFallbackImage && _this2.windowContext.ImageLoader) {
          var customFallbackImage = _this2.container.querySelector('img[data-src]');
          _this2.windowContext.ImageLoader.load(customFallbackImage, { load: true });
        }
      };
      this.events.push({
        'target': this.windowContext,
        'type': 'resize',
        'handler': resizeHandler
      });
      this.windowContext.addEventListener(resizeEvent, resizeHandler, true);
    }

    /**
     * Merge configuration properties with defaults with minimal validation.
     */

  }, {
    key: 'initializeProperties',
    value: function initializeProperties() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      props = (0, _assign2.default)({}, DEFAULT_PROPERTY_VALUES, props);
      if (props.container.nodeType === 1) {
        this.container = props.container;
      } else if (typeof props.container === 'string') {
        this.container = document.querySelector(props.container);
      } else {
        console.error('Container ' + props.container + ' not found');
        return false;
      }
      this.videoId = this.getVideoID(props.url);
      this.filter = props.filter;
      this.filterStrength = props.filterStrength;
      this.useCustomFallbackImage = props.useCustomFallbackImage;
      this.fitMode = props.fitMode;
      this.maxLoops = parseInt(props.maxLoops, 10) || null;
      this.scaleFactor = props.scaleFactor;
      this.playbackSpeed = parseFloat(props.playbackSpeed) === 0.0 ? 1 : parseFloat(props.playbackSpeed);
      this.timeCode = {
        start: this._getStartTime(props.url) || props.timeCode.start,
        end: props.timeCode.end
      };
      this.player = {};
      this.currentLoop = 0;
    }

    /**
     * The ID is the only unique property need to use in the YouTube and Vimeo APIs.
     */

  }, {
    key: 'getVideoID',
    value: function getVideoID(value) {
      if (!value) {
        value = DEFAULT_PROPERTY_VALUES.url;
      }

      var match = value.match(YOUTUBE_REGEX);
      if (match && match[2].length) {
        this.videoSource = 'youtube';
        return match[2];
      }

      match = value.match(VIMEO_REGEX);
      if (match && match[2].length) {
        this.videoSource = 'vimeo';
        return match[2];
      }

      return '';
    }

    /**
     * A default fallback image element will be create from the YouTube API, unless the
     * custom fallback image exists.
     */

  }, {
    key: 'setFallbackImage',
    value: function setFallbackImage() {
      if (this.useCustomFallbackImage) {
        var customFallbackImage = this.container.querySelector('img[data-src]');
        if (!customFallbackImage) {
          return;
        }
        customFallbackImage.addEventListener('load', function () {
          customFallbackImage.classList.add('loaded');
        });
        window.ImageLoader.load(customFallbackImage, { load: true });
      }
    }

    /**
     * Determine which API to use
     */

  }, {
    key: 'callVideoAPI',
    value: function callVideoAPI() {
      if (this.videoSource === 'youtube') {
        this.initializeYouTubeAPI();
      }

      if (this.videoSource === 'vimeo') {
        this.initializeVimeoAPI();
      }
    }

    /**
     * Call YouTube API per their guidelines.
     */

  }, {
    key: 'initializeYouTubeAPI',
    value: function initializeYouTubeAPI() {
      var _this3 = this;

      if (!this.canAutoPlay) {
        return;
      }

      if (this.windowContext.document.documentElement.querySelector('script[src*="www.youtube.com/iframe_api"].loaded')) {
        this.setVideoPlayer();
        return;
      }

      this.player.ready = false;
      var tag = this.windowContext.document.createElement('script');
      tag.src = 'https://www.youtube.com/iframe_api';
      var firstScriptTag = this.windowContext.document.getElementsByTagName('script')[0];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
      tag.addEventListener('load', function (evt) {
        evt.currentTarget.classList.add('loaded');
        _this3.setVideoPlayer();
      }, true);
    }

    /**
     * Call the Vimeo API per their guidelines.
     */

  }, {
    key: 'initializeVimeoAPI',
    value: function initializeVimeoAPI() {
      // No external API call is necessary; preserved for parity with YouTube and
      // potential additional integrations.
      if (!this.canAutoPlay) {
        return;
      }

      this.setVideoPlayer();
    }

    /**
     * If the source is YouTube, initialize the video player and register its callbacks.
     * If the source is Vimeo, construct and append the player node and register handlers.
     */

  }, {
    key: 'setVideoPlayer',
    value: function setVideoPlayer() {
      if (this.player.ready) {
        try {
          this.player.destroy();
          this.player.ready = false;
        } catch (e) {
          // nothing to destroy
        }
      }

      if (this.videoSource === 'youtube') {
        this.initializeYouTubePlayer();
      } else if (this.videoSource === 'vimeo') {
        this.initializeVimeoPlayer();
      }
    }

    /**
     * Initialize the player and bind player events.
     */

  }, {
    key: 'initializeYouTubePlayer',
    value: function initializeYouTubePlayer() {
      var _this4 = this;

      var awaitingLoopRequestedAt = null;

      // Poll until the API is ready.
      if (this.windowContext.YT.loaded !== 1) {
        setTimeout(this.setVideoPlayer.bind(this), 100);
        return false;
      }

      /**
       * YouTube event handler. Add the proper class to the player element, and set
       * player properties. All player methods via YouTube API.
       */
      var onYouTubePlayerReady = function onYouTubePlayerReady(event) {
        var player = _this4.player;
        player.iframe = player.getIframe();
        player.iframe.classList.add('background-video');
        _this4.syncPlayer();
        player.mute();
        var readyEvent = new CustomEvent('ready');
        _this4.container.dispatchEvent(readyEvent);
        document.body.classList.add('ready');
        player.ready = true;
        if (!_this4.canAutoPlay) {
          return;
        }
        if (_this4.timeCode.start >= player.getDuration()) {
          _this4.timeCode.start = 0;
        }
        player.seekTo(_this4.timeCode.start);
        player.playVideo();
        _this4.logger('playing');
      };

      /**
       * YouTube event handler. Determine whether or not to loop the video.
       */
      var onYouTubePlayerStateChange = function onYouTubePlayerStateChange(event) {
        var player = _this4.player;
        var playerIframe = player.getIframe();
        var duration = (player.getDuration() - _this4.timeCode.start) / _this4.playbackSpeed;

        var doLoop = function doLoop() {
          if (awaitingLoopRequestedAt === null) {
            if (player.getCurrentTime() + 0.1 >= player.getDuration()) {
              if (_this4.maxLoops) {
                _this4.currentLoop++;
                if (_this4.currentLoop > _this4.maxLoops) {
                  player.pauseVideo();
                  _this4.currentLoop = 0;
                  return;
                }
              }
              awaitingLoopRequestedAt = player.getCurrentTime();
              player.pauseVideo();
              player.seekTo(_this4.timeCode.start);
            }
          } else if (player.getCurrentTime() < awaitingLoopRequestedAt) {
            awaitingLoopRequestedAt = null;
            player.playVideo();
          }
          requestAnimationFrame(doLoop.bind(_this4));
        };

        if (event.data === _this4.windowContext.YT.PlayerState.BUFFERING && player.getVideoLoadedFraction() !== 1 && (player.getCurrentTime() === 0 || player.getCurrentTime() > duration - -0.1)) {
          _this4.logger('BUFFERING');
          _this4.autoPlayTestTimeout();
        } else if (event.data === _this4.windowContext.YT.PlayerState.PLAYING) {
          if (_this4.player.playTimeout !== null) {
            clearTimeout(_this4.player.playTimeout);
            _this4.player.playTimeout = null;
          }
          if (!_this4.canAutoPlay) {
            _this4.canAutoPlay = true;
            _this4.container.classList.remove('mobile');
          }
          _this4.logger('PLAYING');
          playerIframe.classList.add('ready');
          requestAnimationFrame(doLoop.bind(_this4));
        } else if (event.data === _this4.windowContext.YT.PlayerState.ENDED) {
          player.playVideo();
        }
      };

      var playerElement = this.container.querySelector('#player');
      if (!playerElement) {
        playerElement = document.createElement('div');
        playerElement.id = 'player';
        this.container.appendChild(playerElement);
      }
      this.player = new this.windowContext.YT.Player(playerElement, {
        height: '315',
        width: '560',
        videoId: this.videoId,
        playerVars: {
          'autohide': 1,
          'autoplay': 0,
          'controls': 0,
          'enablejsapi': 1,
          'iv_load_policy': 3,
          'loop': 0,
          'modestbranding': 1,
          'playsinline': 1,
          'rel': 0,
          'showinfo': 0,
          'wmode': 'opaque'
        },
        events: {
          'onReady': function onReady(event) {
            onYouTubePlayerReady(event);
          },
          'onStateChange': function onStateChange(event) {
            onYouTubePlayerStateChange(event);
          }
        }
      });
    }

    /**
     * Initialize the player and bind player events with a postMessage handler.
     */

  }, {
    key: 'initializeVimeoPlayer',
    value: function initializeVimeoPlayer() {
      var _this5 = this;

      var playerIframe = this.windowContext.document.createElement('iframe');
      playerIframe.id = 'vimeoplayer';
      playerIframe.classList.add('background-video');
      var playerConfig = '&background=1';
      playerIframe.src = '//player.vimeo.com/video/' + this.videoId + '?api=1' + playerConfig;
      this.container.appendChild(playerIframe);
      this.player.iframe = playerIframe;

      /**
       * Creates cross frame postMessage handlers, gets proper dimensions of player,
       * and sets ready state for the player and container.
       *
       */
      var player = this.player;
      var playerOrigin = '*';

      var postMessageManager = function postMessageManager(action, value) {
        var data = {
          method: action
        };

        if (value) {
          data.value = value;
        }

        var message = (0, _stringify2.default)(data);
        _this5.windowContext.eval('(function(ctx){ ctx.player.iframe.contentWindow.postMessage(' + message + ', ' + (0, _stringify2.default)(playerOrigin) + '); })')(_this5);
      };
      player.postMessageManager = postMessageManager;

      var syncAndStartPlayback = function syncAndStartPlayback() {
        if (!player.dimensions.width || !player.dimensions.height || !player.duration) {
          return;
        }
        _this5.syncPlayer();

        var readyEvent = new CustomEvent('ready');
        _this5.container.dispatchEvent(readyEvent);
        document.body.classList.add('ready');

        // Only required for Vimeo Basic videos, or video URLs with a start time hash.
        // Plus and Pro utilize `background=1` URL parameter.
        // See https://vimeo.com/forums/topic:278001
        postMessageManager('setVolume', '0');
        postMessageManager('setLoop', 'true');
        postMessageManager('seekTo', _this5.timeCode.start);
        postMessageManager('play');
        postMessageManager('addEventListener', 'playProgress');
      };

      var onReady = function onReady() {
        player.dimensions = {};
        postMessageManager('getDuration');
        postMessageManager('getVideoHeight');
        postMessageManager('getVideoWidth');
      };

      var onPlaying = function onPlaying() {
        clearTimeout(player.playTimeout);
        player.playTimeout = null;
        player.ready = true;
        player.iframe.classList.add('ready');

        if (!_this5.canAutoPlay) {
          _this5.canAutoPlay = true;
          _this5.container.classList.remove('mobile');
        }
      };

      var onMessageReceived = function onMessageReceived(event) {
        if (!/^https?:\/\/player.vimeo.com/.test(event.origin)) {
          return false;
        }

        playerOrigin = event.origin;

        var data = event.data;
        if (typeof data === 'string') {
          data = JSON.parse(data);
        }
        _this5.logger(data);

        switch (data.event) {
          case 'ready':
            onReady();
            break;

          case 'playProgress':
          case 'timeupdate':
            postMessageManager('setVolume', '0');
            if (player.playTimeout !== null) {
              onPlaying();
            }
            if (data.data.percent >= 0.98 && _this5.timeCode.start > 0) {
              postMessageManager('seekTo', _this5.timeCode.start);
            }
            break;
        }

        switch (data.method) {
          case 'getVideoHeight':
            player.dimensions.height = data.value;
            syncAndStartPlayback();
            break;
          case 'getVideoWidth':
            player.dimensions.width = data.value;
            syncAndStartPlayback();
            break;
          case 'getDuration':
            player.duration = data.value;
            if (_this5.timeCode.start >= player.duration) {
              _this5.timeCode.start = 0;
            }
            syncAndStartPlayback();
            break;
        }
      };

      var messageHandler = function messageHandler(e) {
        onMessageReceived(e);
      };

      this.windowContext.addEventListener('message', messageHandler, false);
      this.autoPlayTestTimeout();

      player.destroy = function () {
        _this5.windowContext.removeEventListener('message', messageHandler);
        // If the iframe node has already been removed from the DOM by the
        // implementer, parentElement.removeChild will error out unless we do
        // this check here first.
        if (player.iframe.parentElement) {
          player.iframe.parentElement.removeChild(player.iframe);
        }
      };
    }

    /**
     * The IFRAME will be the entire width and height of its container, but the video
     * may be a completely different size and ratio. Scale up the IFRAME so the inner video
     * behaves in the proper `fitMode`, with optional additional scaling to zoom in.
     */

  }, {
    key: 'scaleVideo',
    value: function scaleVideo(scaleValue) {
      var scale = scaleValue || this.scaleFactor;
      var playerIframe = this.player.iframe;
      var videoDimensions = this._findPlayerDimensions();

      if (this.fitMode !== 'fill') {
        playerIframe.style.width = '';
        playerIframe.style.height = '';
        return false;
      }

      var containerWidth = playerIframe.parentNode.clientWidth;
      var containerHeight = playerIframe.parentNode.clientHeight;
      var containerRatio = containerWidth / containerHeight;
      var videoRatio = videoDimensions.width / videoDimensions.height;
      var pWidth = 0;
      var pHeight = 0;
      if (containerRatio > videoRatio) {
        // at the same width, the video is taller than the window
        pWidth = containerWidth * scale;
        pHeight = containerWidth * scale / videoRatio;
        playerIframe.style.width = pWidth + 'px';
        playerIframe.style.height = pHeight + 'px';
      } else if (videoRatio > containerRatio) {
        // at the same width, the video is shorter than the window
        pWidth = containerHeight * scale * videoRatio;
        pHeight = containerHeight * scale;
        playerIframe.style.width = pWidth + 'px';
        playerIframe.style.height = pHeight + 'px';
      } else {
        // the window and video ratios match
        pWidth = containerWidth * scale;
        pHeight = containerHeight * scale;
        playerIframe.style.width = pWidth + 'px';
        playerIframe.style.height = pHeight + 'px';
      }
      playerIframe.style.left = 0 - (pWidth - containerWidth) / 2 + 'px';
      playerIframe.style.top = 0 - (pHeight - containerHeight) / 2 + 'px';
    }

    /**
     * Play back speed options, based on the YouTube API options.
     */

  }, {
    key: 'setSpeed',
    value: function setSpeed(speedValue) {
      this.playbackSpeed = parseFloat(this.playbackSpeed);
      this.player.setPlaybackRate(this.playbackSpeed);
    }

    /**
     * All diplay related effects should be applied prior to the video loading to
     * ensure the effects are visible on the fallback image while loading.
     */

  }, {
    key: 'setDisplayEffects',
    value: function setDisplayEffects() {
      this.setFilter();
    }

    /**
     * Apply filter with values based on filterStrength.
     */

  }, {
    key: 'setFilter',
    value: function setFilter() {
      var containerStyle = this.container.style;
      var filter = FILTER_OPTIONS[this.filter - 1];
      var filterStyle = '';
      if (filter !== 'none') {
        filterStyle = this.getFilterStyle(filter, this.filterStrength);
      }

      // To prevent the blur effect from displaying the background at the edges as
      // part of the blur, the filer needs to be applied to the player and fallback image,
      // and those elements need to be scaled slightly.
      // No other combination of filter target and scaling seems to work.
      if (filter === 'blur') {
        containerStyle.webkitFilter = '';
        containerStyle.filter = '';
        this.container.classList.add('filter-blur');

        Array.prototype.slice.call(this.container.children).forEach(function (el) {
          el.style.webkitFilter = filterStyle;
          el.style.filter = filterStyle;
        });
      } else {
        containerStyle.webkitFilter = filterStyle;
        containerStyle.filter = filterStyle;
        this.container.classList.remove('filter-blur');

        Array.prototype.slice.call(this.container.children).forEach(function (el) {
          el.style.webkitFilter = '';
          el.style.filter = '';
        });
      }
    }

    /**
     * Construct the style based on the filter, strength and `FILTER_PROPERTIES`.
     */

  }, {
    key: 'getFilterStyle',
    value: function getFilterStyle(filter, strength) {
      return filter + '(' + (FILTER_PROPERTIES[filter].modifier(strength) + FILTER_PROPERTIES[filter].unit) + ')';
    }

    /**
     * The YouTube API seemingly does not expose the actual width and height dimensions
     * of the video itself. The video's dimensions and ratio may be completely different
     * than the IFRAME's. This hack finds those values inside some private objects.
     * Since this is not part of the pbulic API, the dimensions will fall back to the
     * container width and height, in case YouTube changes the internals unexpectedly.
     */

  }, {
    key: '_findPlayerDimensions',
    value: function _findPlayerDimensions() {
      var w = void 0;
      var h = void 0;
      var player = this.player;
      if (this.videoSource === 'youtube' && player) {
        for (var p in player) {
          var prop = player[p];
          if ((typeof prop === 'undefined' ? 'undefined' : (0, _typeof3.default)(prop)) === 'object' && prop.width && prop.height) {
            w = prop.width;
            h = prop.height;
            break;
          }
        }
      } else if (this.videoSource === 'vimeo' && player) {
        if (player.dimensions) {
          w = player.dimensions.width;
          h = player.dimensions.height;
        } else if (player.iframe) {
          w = player.iframe.clientWidth;
          h = player.iframe.clientHeight;
        }
      }
      if (!w || !h) {
        w = this.container.clientWidth;
        h = this.container.clientHeight;
        console.warn('Video player dimensions not found.');
      }
      return {
        'width': w,
        'height': h
      };
    }

    /**
     * Get the start time base on the URL formats of YouTube and Vimeo.
     */

  }, {
    key: '_getStartTime',
    value: function _getStartTime(url) {
      var parsedUrl = new _urlParse2.default(url, true);
      var timeParam = this._getTimeParameter(parsedUrl);
      if (!timeParam) {
        return false;
      }

      var timeRegexYoutube = /[hms]/;
      var timeRegexVimeo = /[#t=s]/;

      var match = void 0;
      switch (this.videoSource) {
        case 'youtube':
          match = timeParam.split(timeRegexYoutube).filter(Boolean);
          break;
        case 'vimeo':
          match = timeParam.split(timeRegexVimeo).filter(Boolean);
          break;
      }
      var s = parseInt(match.pop(), 10) || 0;
      var m = parseInt(match.pop(), 10) * 60 || 0;
      var h = parseInt(match.pop(), 10) * 3600 || 0;
      return h + m + s;
    }

    /**
     * YouTube and Vimeo have optional URL formats to allow playback at a certain
     * timecode.
     * Returns the appropriate time parameter or false.
     */

  }, {
    key: '_getTimeParameter',
    value: function _getTimeParameter(parsedUrl) {
      if (this.videoSource === 'youtube' && (!parsedUrl.query || !parsedUrl.query.t) || this.videoSource === 'vimeo' && !parsedUrl.hash) {
        return false;
      }
      var timeParam = void 0;
      if (this.videoSource === 'youtube') {
        timeParam = parsedUrl.query.t;
      } else if (this.videoSource === 'vimeo') {
        timeParam = parsedUrl.hash;
      }
      return timeParam;
    }

    /**
      * Since we cannot inspect the video element inside the provider's IFRAME to
      * check for `autoplay` and `playsinline` attributes, set a timeout that will
      * tell this instance that the media cannot auto play. The timeout will be
      * cleared via the media's playback API if it does begin playing.
      */

  }, {
    key: 'autoPlayTestTimeout',
    value: function autoPlayTestTimeout() {
      var _this6 = this;

      this.player.playTimeout = setTimeout(function () {
        _this6.canAutoPlay = false;
        _this6.container.classList.add('mobile');
        _this6.logger('added mobile');
      }, 2500);
    }

    /**
      * Apply the purely visual effects.
      */

  }, {
    key: 'syncPlayer',
    value: function syncPlayer() {
      this.setDisplayEffects();
      if (this.videoSource === 'youtube') {
        this.setSpeed();
      }
      this.scaleVideo();
    }
  }, {
    key: 'logger',
    value: function logger(msg) {
      if (!DEBUG) {
        return;
      }

      console.log(msg);
    }
  }]);
  return VideoBackground;
}();

exports.default = VideoBackground;