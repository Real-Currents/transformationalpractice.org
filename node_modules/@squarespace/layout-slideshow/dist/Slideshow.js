'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _layoutBase = require('@squarespace/layout-base');

var _layoutBase2 = _interopRequireDefault(_layoutBase);

var _core = require('@squarespace/core');

var _createStyleNode = require('./utils/createStyleNode');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var activeClassname = 'active';
var defaultConfig = {
  loop: true,
  imageLoaderOptions: {
    load: true,
    mode: 'fill'
  },
  autoplay: {
    enabled: false
  }
};

/**
 * A class to create a slideshow layout. Setting the `index` property will
 * automatically advance the slide to that index.
 */

var Slideshow = function (_LayoutBase) {
  (0, _inherits3.default)(Slideshow, _LayoutBase);

  /**
   * @param  {HTMLElement} rootNode                               Node containing slideshow
   * @param  {Object}      config                                 Config object
   * @param  {String}      config.elementSelector                 Selector of child element
   * @param  {Number}      config.transitionDuration              Duration of transition
   * @param  {Boolean}     config.loop                            Whether or not to loop back to the beginning/end
   * @param  {Object}      config.controls                        Object with controls selector
   * @param  {String}      config.controls.previous               Selector for previous control
   * @param  {String}      config.controls.next                   Selector for next control
   * @param  {String}      config.controls.indicators             Selector for individual indicator
   * @param  {Object}      config.autoplay                        Object with autoplay config
   * @param  {Boolean}     config.autoplay.enabled                Whether autoplay is enabled
   * @param  {Number}      config.autoplay.delay                  Duration of each autoplay slide
   * @param  {Function}    config.autoplay.afterInteractionEnd    Callback to execute after mousing out
   * @param  {Function}    config.imageLoaderOptions              ImageLoader config
   */
  function Slideshow(rootNode, config) {
    (0, _classCallCheck3.default)(this, Slideshow);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Slideshow.__proto__ || (0, _getPrototypeOf2.default)(Slideshow)).call(this, rootNode, (0, _assign2.default)({}, defaultConfig, config)));

    _this._index = 0;
    _this.eventHandlers = [];
    return _this;
  }

  /**
   * @return {Number} Current Index
   */


  (0, _createClass3.default)(Slideshow, [{
    key: 'on',


    /**
     * Convenience method for attaching event handlers. Binds context, and keeps
     * track of all event handlers so they can be easily detached.
     * @param  {HTMLElement} node      Node to add event listener to
     * @param  {String}      event     Event type to listen to
     * @param  {Function}    callback  Function to run when event occurs
     */
    value: function on(node, event, callback) {
      var boundCallback = callback.bind(this);
      this.eventHandlers.push({ node: node, event: event, boundCallback: boundCallback });
      node.addEventListener(event, boundCallback);
    }

    /**
     * Apply relevant styles for the gallery by generating a CSS style node with
     * innerText being the styles.
     */

  }, {
    key: 'setStyles',
    value: function setStyles() {
      var _styleText;

      this.rootNode.classList.add('gallery-root');
      if (this.styleNode) {
        this.rootNode.removeChild(this.styleNode);
      }
      var styleText = (_styleText = {
        '.gallery-root': {
          position: 'relative'
        }
      }, (0, _defineProperty3.default)(_styleText, this.config.elementSelector, {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%'
      }), (0, _defineProperty3.default)(_styleText, this.config.elementSelector + ':not(.active)', {
        opacity: 0,
        'z-index': 0
      }), (0, _defineProperty3.default)(_styleText, this.config.elementSelector + '.active', {
        opacity: 1,
        'z-index': 1
      }), _styleText);
      this.styleNode = (0, _createStyleNode.createStyleNode)(styleText);
      this.rootNode.appendChild(this.styleNode);
    }

    /**
     * Convenience method to take a callback function (provided by the implementer
     * of this class), validate it, and run it if it is a function.
     * @param  {Function} fn  Callback to execute
     */

  }, {
    key: 'executeCallback',
    value: function executeCallback(fn) {
      if (typeof fn !== 'function') {
        console.error('Callback is not a function');
        return;
      }
      fn();
    }

    /**
     * Given the config.elementSelector, selects all elements matching that
     * selector in the rootNode and returns them as an Array.
     * @return {Array}
     */

  }, {
    key: 'getElements',
    value: function getElements() {
      var els = this.rootNode.querySelectorAll(this.config.elementSelector);
      return (0, _from2.default)(els);
    }

    /**
     * Given the indicators' selector from config, returns an array of all the
     * elements matching that selector in the rootNode and returns them as an
     * Array.
     * @return {Array}
     */

  }, {
    key: 'getIndicators',
    value: function getIndicators() {
      if (!this.config.controls || !this.config.controls.indicators) {
        return null;
      }
      var indicators = this.rootNode.querySelectorAll(this.config.controls.indicators);
      return (0, _from2.default)(indicators);
    }

    /**
     * Given an index, adds the active classname to the element and the indicator
     * corresponding to that index.
     * @param {Number} index
     */

  }, {
    key: 'setActiveElement',
    value: function setActiveElement() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      this.elements.forEach(function (el, i) {
        el.classList.toggle(activeClassname, i === index);
      });

      // Indicator
      if (!this.indicators) {
        return;
      }
      this.indicators.forEach(function (el, i) {
        el.classList.toggle(activeClassname, i === index);
      });
    }

    /**
     * Select the first image with data-src attribute in each element, and loads
     * loads the image with provided imageLoaderOptions.
     */

  }, {
    key: 'loadImages',
    value: function loadImages() {
      var _this2 = this;

      this.elements.forEach(function (el) {
        var img = el.querySelector('img[data-src]');
        _core.ImageLoader.load(img, _this2.config.imageLoaderOptions);
      });
    }

    /**
     * Starts autoplay, and binds handlers to stop autoplay on mouseover and
     * restart it on mouseout.
     */

  }, {
    key: 'setupAutoplay',
    value: function setupAutoplay() {
      var _this3 = this;

      if (!this.config.autoplay || !this.config.autoplay.enabled) {
        return;
      }
      this.startAutoplay();

      // Mouseover and mouseout will mess with the controls click handler if this
      // is a touch device, so don't bind them in those situations.
      if ('ontouchstart' in document.documentElement) {
        return;
      }

      this.on(this.rootNode, 'mouseover', function () {
        _this3.isInteracting = true;
        _this3.rootNode.classList.add('interacting');
        _this3.stopAutoplay();
      });
      this.on(this.rootNode, 'mouseout', function () {
        _this3.isInteracting = false;
        _this3.rootNode.classList.remove('interacting');
        _this3.executeCallback(_this3.config.afterInteractionEnd);
        _this3.startAutoplay();
      });
    }

    /**
     * Starts autoplay if it's enabled, and there isn't already an autoplay
     * timeout running.
     */

  }, {
    key: 'startAutoplay',
    value: function startAutoplay() {
      var _this4 = this;

      if (!this.config.autoplay || !this.config.autoplay.enabled || this.autoplayTimeout) {
        return;
      }

      this.autoplayTimeout = setTimeout(function () {
        _this4.index++;
      }, this.config.autoplay.delay || 5000);
    }

    /**
     * Stops autoplay, clearing the autoplay timeout if there is one.
     */

  }, {
    key: 'stopAutoplay',
    value: function stopAutoplay() {
      clearTimeout(this.autoplayTimeout);
      this.autoplayTimeout = null;
    }

    /**
     * Walk up the DOM to find a target that matches one of the array of given
     * selectors. Used for click handlers.
     *
     * @param  {HTMLElement} initialTarget  Node to start walking the DOM from
     * @param  {Array}       selectors      Selectors to check against
     * @return {HTMLElement}                Found element, or null if none
     */

  }, {
    key: 'findAncestor',
    value: function findAncestor(initialTarget, selectors) {
      var match = function match(el) {
        return selectors.some(function (sel) {
          return el.matches(sel);
        });
      };
      var target = initialTarget;
      while (!match(target) && target !== this.rootNode) {
        target = target.parentElement;
      }

      if (!target || target === this.rootNode) {
        return null;
      }

      return target;
    }

    /**
     * Click handler for controls. When anything is clicked, walk up the DOM
     * to determine whether or not it's a control or an ancestor of a control.
     * If so, set the index to the proper number.
     *
     * The click intentionally does not do anything if the gallery is in the
     * middle of a transition.
     *
     * @param  {Object} e  Click event object
     */

  }, {
    key: 'handleControlsClick',
    value: function handleControlsClick(e) {
      var _this5 = this;

      if (this.isTransitioning) {
        return;
      }

      var selectors = (0, _values2.default)(this.config.controls);
      var target = this.findAncestor(e.target, selectors);

      if (!target) {
        return;
      }

      e.preventDefault();

      if (target.matches(this.config.controls.previous)) {
        this.index--;
      } else if (target.matches(this.config.controls.next)) {
        this.index++;
      } else if (target.matches(this.config.controls.indicators)) {
        this.indicators.forEach(function (el, i) {
          if (target === el) {
            _this5.index = i;
          }
        });
      } else {
        return;
      }
    }

    /**
     * Gets indicators, and adds event listener for click on rootNode.
     */

  }, {
    key: 'setupControls',
    value: function setupControls() {
      if (!this.config.controls) {
        return;
      }

      this.indicators = this.getIndicators();
      this.on(this.rootNode, 'click', this.handleControlsClick);
    }

    /**
     * Figures out if the rootNode is currently visible.
     * @return {Boolean}
     */

  }, {
    key: 'isInView',
    value: function isInView() {
      var _rootNode$getBounding = this.rootNode.getBoundingClientRect(),
          top = _rootNode$getBounding.top,
          height = _rootNode$getBounding.height;

      if (top >= window.innerHeight || top + height <= 0) {
        return false;
      }
      return true;
    }

    /**
     * Keydown handler. If left or right arrow keys are pressed and this slideshow
     * is in view, increment or decrement the index.
     * @param  {Object} e  Keydown event object
     * @return {Number}    Current index
     */

  }, {
    key: 'handleKeydown',
    value: function handleKeydown(e) {
      if (this.isTransitioning || !this.isInView()) {
        return;
      }

      var isLeftArrow = e.keyCode === 37;
      var isRightArrow = e.keyCode === 39;

      if (!isLeftArrow && !isRightArrow) {
        return;
      }

      e.preventDefault();
      e.stopImmediatePropagation();

      return isRightArrow ? this.index++ : this.index--;
    }

    /**
     * Binds the keydown handler to keydown.
     */

  }, {
    key: 'setupKeydown',
    value: function setupKeydown() {
      this.on(window, 'keydown', this.handleKeydown);
    }

    /**
     * Resize handler. Reloads images, and runs the afterResize callback if there
     * is one.
     */

  }, {
    key: 'handleResize',
    value: function handleResize() {
      this.loadImages();
      if (typeof this.config.afterResize === 'function') {
        this.config.afterResize();
      }
    }

    /**
     * The master layout function. Runs all the logic needed to lay out the
     * slideshow.
     * @param  {Object} config  Updated config object
     */

  }, {
    key: 'layout',
    value: function layout(config) {
      this.beforeLayout(config);
      this.setStyles();
      this.elements = this.getElements();
      this.setActiveElement(0);
      this.loadImages();
      this.setupAutoplay();
      this.setupControls();
      this.setupKeydown();
      this.on(window, 'resize', this.handleResize);
      this.afterLayout();
    }

    /**
     * Destructor. Clears timeouts, unbinds event listeners, and removes the style
     * node added by setStyles.
     * @param  {Object} config  Updated config object
     */

  }, {
    key: 'destroy',
    value: function destroy(config) {
      this.beforeDestroy();

      // Clear autoplay
      this.stopAutoplay();

      // Clear transition timeout
      clearTimeout(this.transitionTimeout);

      // Unbind event handlers
      this.eventHandlers.forEach(function (handler) {
        var node = handler.node,
            event = handler.event,
            boundCallback = handler.boundCallback;

        node.removeEventListener(event, boundCallback);
      });
      this.eventHandlers = [];

      // Remove style node
      this.styleNode.parentNode.removeChild(this.styleNode);

      this.afterDestroy();
    }
  }, {
    key: 'index',
    get: function get() {
      return this._index;
    }

    /**
     * Sets index, updating the private variable to the new index provided, and
     * handling all logic to advance the slide to that number, including adding
     * the active classname, restarting autoplay, and setting the timeout for
     * the transition delay if configured.
     * @param  {Number} newIndex
     */
    ,
    set: function set(newIndex) {
      var _this6 = this;

      if (newIndex > this.elements.length - 1) {
        if (!this.config.loop) {
          return;
        }
        this._index = 0;
      } else if (newIndex < 0) {
        if (!this.config.loop) {
          return;
        }
        this._index = this.elements.length - 1;
      } else {
        this._index = newIndex;
      }
      this.setActiveElement(this._index);

      // Transition delay
      if (this.config.transitionDuration) {
        this.isTransitioning = true;
        this.transitionTimeout = setTimeout(function () {
          _this6.isTransitioning = false;
        }, this.config.transitionDuration);
      }

      // Autoplay
      if (!this.isInteracting) {
        this.stopAutoplay();
        this.startAutoplay();
      }
    }
  }]);
  return Slideshow;
}(_layoutBase2.default);

exports.default = Slideshow;
module.exports = exports['default'];